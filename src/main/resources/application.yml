server:
  port: 8082

spring:
  datasource:
    url: jdbc:mysql://10.0.114.30:3308/notidb?useSSL=false&serverTimezone=Asia/Seoul&characterEncoding=utf8
    username: root
    password: 1234
    driver-class-name: com.mysql.cj.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: update
    open-in-view: false

  cloud:
    function:
      definition: orderScsConsumer;orderKafkaConsumer;orderDltLogger # 컨슈머를 함수형으로 등록
    stream:
      default:
        content-type: application/json
      bindings:
        # SCS 발행 수신 (헤더에 contentType 포함 → 기본 디코딩)
        orderScsConsumer-in-0:
          destination: order-created-scs
          group: noti-scs-group
          content-type: application/json
          consumer:
            use-native-decoding: false   # ← 명시적으로 SCS 디코딩
            max-attempts: 4 # 실패 즉시 DLT로 전송 재시도 4번

            # === 재시도/백오프 ===
            back-off-initial-interval: 500
            back-off-multiplier: 2.0
            back-off-max-interval: 10

            defaultRetryable: false # 기본값을 비재시도로 두고 필요한 예외만 true로 켠다면 ↓
            retryable-exceptions:
              java.lang.IllegalArgumentException: false
              org.springframework.dao.DataIntegrityViolationException: true
              java.sql.SQLTransientException: true
              java.sql.SQLRecoverableException: true
              org.springframework.dao.TransientDataAccessResourceException: true

        # KafkaTemplate 발행 수신 (헤더 없음 → native 디코딩 필수)
        orderKafkaConsumer-in-0:
          destination: order-created-kafka
          group: noti-kafka-group
          content-type: application/json
          consumer:
            use-native-decoding: true

        orderDltLogger-in-0:
          destination: order-created-scs.noti-scs-group.DLT
          group: noti-dlt-monitor
          content-type: application/json
          consumer:
            use-native-decoding: false

      # Kafka 바인더 공통
      kafka:
        binder:
          brokers: 10.0.114.30:29092
        # 바인딩별 Kafka 원시 설정 주입 (native-decoding일 때 필요)
        bindings:
          orderKafkaConsumer-in-0:
            consumer:
              startOffset: latest
              configuration:
                key.deserializer: org.apache.kafka.common.serialization.StringDeserializer
                value.deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
                spring.json.trusted.packages: com.dean.study.flux.*
                spring.json.value.default.type: com.dean.study.flux.noti.dto.OrderCreatedEvent
                spring.json.use.type.headers: false
                auto.offset.reset: latest

          # 바인딩 키 - 카프카전용
          orderScsConsumer-in-0:
            consumer:
              # Kafka 전용(바인더) 설정
              enableDlq: true                  # DLT 사용
              dlqName: order-created-scs.noti-scs-group.DLT  # (원하면 직접 이름 고정)
              autoCommitOnError: false       # 실패 시 오프셋 커밋 제어 (옵션)



  kafka:
    bootstrap-servers: 10.0.114.30:29092
    consumer:
      auto-offset-reset: latest # 토픽의 가장 최근(offset end) 이후부터 읽기 시작 - 애플리케이션 실행 이후에 들어오는 새 메시지부터 소비

logging:
  level:
    com.dean.study.flux.noti: DEBUG
    org.hibernate.SQL: DEBUG

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,circuitbreakerevents,bindings
  endpoint:
    health:
      show-details: always